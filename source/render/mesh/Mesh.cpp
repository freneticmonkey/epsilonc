#include "render/mesh/Mesh.h"
#include "resource/ResourceManager.h"

namespace epsilon
{
	Mesh::Ptr Mesh::Create()
	{
		return std::make_shared<Mesh>(private_struct());
	}

	Mesh::Ptr Mesh::CreateFromFile(std::string filename)
	{
		return std::make_shared<Mesh>(private_struct(), filename);
	}

	Mesh::Mesh(const private_struct &) : Resource("", ResourceType::Type::MESH), 
										 Object("Mesh"), 
										 drawOk(true), 
										 needGPUCopy(true)
	{
		vd = VertexData::Create();
	}

	Mesh::Mesh(const private_struct &, std::string filename) : Resource(filename, ResourceType::Type::MESH), 
															   Object("Mesh"), 
															   drawOk(true), 
															   needGPUCopy(true)
	{
		vd = VertexData::Create();

		// Name the Mesh - This should really be done by the MeshManager because of duplicate filenames
		objectName = filename;

		// strip the path and just use the filename
		unsigned spos = filename.rfind("/");
		if (spos != std::string::npos)
		{
			objectName = filename.substr(spos + 1, std::string::npos);
		}

		filename = ResourceManager::GetInstance().GetResourceFullPath(filename);
		UpdateResourceFilename(filename);
	}

	Mesh::~Mesh(void)
	{
	}
    
    void Mesh::Destroy()
    {
        if ( vd->HasBuiltBuffers())
        {
            vd->Destroy();
        }
    }
	
	bool Mesh::Draw()
	{
		if (needGPUCopy)
		{
			// We should only be getting here 
			// from meshes generated by mesh manager 
			// Loaded meshes should be processing this beforehand
			ProcessMesh();
		}
		drawOk = vd->Draw();
		return drawOk;
	}

	bool Mesh::SetMeshLoader(MeshLoaderInterface::Ptr iMeshLoader)
	{
		bool result = false;
		if (iMeshLoader->CanLoad(GetFilepath().GetString()))
		{
			meshLoader = iMeshLoader;
			result = true;
		}
		return result;
	}

	void Mesh::LoadMesh()
	{
		// Load Texture	
		if (meshLoader)
		{
			// Read the file from disk
			meshLoader->LoadMesh(GetFilepath().GetString(), vd);

			// mark the file as reloaded regardless of whether the texture was loaded or not.
			SetReloaded();
		}
	}

	void Mesh::ProcessMesh()
	{
		// If we are reloading the Mesh.
		if (reloadVd && vd)
		{
			// First Destroy the existing mesh.
			vd->Destroy();

			// Assign the reloaded VertexData as the main VertexData
			vd = reloadVd;

			// remove reference to the reloaded data
			reloadVd = nullptr;
		}

		// Load that data yo!
		if (!vd->HasBuiltBuffers())
		{
			vd->BuildBuffers();

			needGPUCopy = false;
		}
	}

	void Mesh::RefreshFromFile()
	{
		// Do the refresh
		if (meshLoader)
		{
			reloadVd = VertexData::Create();

			// Load the texture data from disk
			meshLoader->RefreshMesh(GetFilepath().GetString(), reloadVd);

			needGPUCopy = true;
		}

		// mark the file as reloaded regardless of whether the texture was loaded or not.
		SetReloaded();
	}

	void Mesh::RefreshBuffers()
	{
		// If the texture needs to be refresh continue.
		if (meshLoader && needGPUCopy)
		{
			// Push the new mesh data to OpenGL
			ProcessMesh();
		}
	}

}